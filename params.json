{"name":"ku4js-data","tagline":"kodmunki™ utilities for JavaScript data","body":"ku4js-data\r\n==============\r\n\r\nkodmunki™ utilities for JavaScript data.\r\n\r\nThis library includes Query String and JSON parsers, Data Transfer Objects, ajax services, and persistent, validatable, and transferable forms\r\n\r\n<img src=\"http://www.kodmunki.com/media/logo-small.png\" alt=\"kodmunki\" />\r\n\r\n---\r\n\r\n#Documentation\r\nThe following documentation describes each class in the ku4js-data library. It is organized to follow the directory structure found in /src ordered by lowest level constructs first. All instantiable classes can be instantiated using the $.className() syntax. All constructors are empty unless otherwise noted.\r\n\r\nThe API tables in each section of the documentation contain three columns.\r\n\r\n| API | Return | Description |\r\n| --- | --- | --- |\r\n|This column contains the actual JavaScript API of the property or method in question. Proper syntax is depicted. Argument types are displyed in italics. Class/static methods are denoted with the class name, whereas instance level methods will begin with a dot. Example class/static method: **$.math.round(value:_Number_, nearest:_Number_)**. Example of an instance method: **.toString()** | The return values type, if any. A value of \"this\" in this column indicates the return of a reference to self | This column contains descriptions and any **Gotchas!** |\r\n\r\n##Ajax\r\n\r\n###serivce\r\n| API | Return | Description |\r\n| --- | --- | --- |\r\n| .processId() | uid |  |\r\n| .GET() | this |  |\r\n| .POST() | this |  |\r\n| .PUT() | this |  |\r\n| .HEAD() | this |  |\r\n| .OPTIONS() | this |  |\r\n| .DELETE() | this |  |\r\n| .TRACE() | this |  |\r\n| .CONNECT() | this |  |\r\n| .xhr() | this |  |\r\n| .xss() | this |  |\r\n| .sync() | this |  |\r\n| .async() | this |  |\r\n| .text() | this |  |\r\n| .xml() | this |  |\r\n| .verb(value:_String_) | this |  |\r\n| .uri(value:_String_) | this |  |\r\n| .contentType(value:_String_) | this |  |\r\n| .responseType(value:_String_) | this |  |\r\n| .strategy(value:_Strategy_) | this |  |\r\n| .maxAttempts(value:_Number_) | this |  |\r\n| .isLocal() | Boolean |  |\r\n| .isAsync() | Boolean |  |\r\n| .isLocked() | Boolean |  |\r\n| .isBusy() | Boolean |  |\r\n| .lock() | this |  |\r\n| .unlock() | this |  |\r\n| .onSuccess(func:_Function_, scope:_Object_, id:_String_) | this |  |\r\n| .onError(func:_Function_, scope:_Object_, id:_String_)  | this |  |\r\n| .onComplete(func:_Function_, scope:_Object_, id:_String_)  | this |  |\r\n| .removeListener(id:_String_) | this |  |\r\n| .clearListeners() | this |  |\r\n\r\n##Data\r\n\r\n###cookie\r\n_Documentation Coming Soon_\r\n\r\n###dto\r\n\r\nA powerful DTO (Data Transfer Object). This class is excellent for passing\r\ndata around an application as it can easily be transfered to an object, array, query string, JSON, or multipart form data.\r\n\r\n| API | Return | Description |\r\n| --- | --- | --- |\r\n| .toObject() | {} or [] | Returns an object literal or array representation of the contained data, depending upon what is the contained data. |\r\n| .toJson() | String | Returns the dto key, value pairs as a JSON string. |\r\n| .toQueryString() | String | Returns the dto key, value pairs as a Query String |\r\n| .toFormData() | FormData | Returns a FromData representation of  the dto data. |\r\n| .saveAs(name:_String_) | this | Saves the dto key, value pairs to a cookie with name. |\r\n| .save() | String | Saves the dto key, value pairs to a cookie with name. |\r\n| .erase() | this | Erases the current dto from the cookie. |\r\n\r\n###json\r\n_Documentation Coming Soon_\r\n\r\n###queryString\r\n_Documentation Coming Soon_\r\n\r\n##Form\r\n\r\n###field\r\n_Documentation Coming Soon_\r\n\r\n###form\r\n_Documentation Coming Soon_\r\n\r\n###specs\r\n_Documentation Coming Soon_\r\n\r\n###Fields\r\n\r\n####checkbox\r\n_Documentation Coming Soon_\r\n\r\n####radioset\r\n_Documentation Coming Soon_\r\n\r\n####select\r\n_Documentation Coming Soon_\r\n\r\n##Persistence\r\n\r\n###collection\r\n| API | Return | Description |\r\n| --- | --- | --- |\r\n| .find(query:_{}_) | Array | Returns an array containing the results of the query. More on find below. |\r\n| .insert(entity:_Object_) | object | String | Inserts the entity into the collection |\r\n| .update(criteria:_{}_, updates:_{}_) | this | Updates all entities that satisfy the criteria with the data in updates. |\r\n| .remove(criteria:_{}_) | this | Removes all entities that satisfy the criteria. |\r\n| .join(otherCollection:_collection_, on:_String_, equals:_Object_) | collection | Joins this collection with otherCollection on collection[on] == otherCollection[equals] |\r\n| .join(otherCollection:_collection_, func:_Function_) | collection | Joins this collection with otherCollection based upon the boolean return value of the passed function. The passed function will receive two parameters for each possibility combination of joins that can be used to evaluate the intention ot join. |\r\n| .exec(func:_Function_) | collection | Runs the function for each item in the results passing the result as the argument to the function. Then function should return a value as that value will be the value in the find results. |\r\n| .init(array:_Array<Object>_) | this | Clears this collection and initializes it with the entities in the array. |\r\n| .save() | this | Saves this collection to localStorage (as available). |\r\n\r\n####Find\r\nThe find method is the means by which you can query your collections. There are many ways to query a collection from\r\nsimple to complex. These methods are described below:\r\n\r\n#####Simple Find\r\nThe first method of querying is the most simple. It is a direct query in which you are saying, \"Give me\r\nthe objects in the collection that exactly match my query.\" To do this you pass an object containing the keys that you\r\nwould like to query and have values equal to that, that you are expecting. For example\r\n```javascript\r\nmyCollection.find({\"name\": \"myName\"}).;\r\n```\r\nThis specifies that you would like to get back all records that have a \"name\" with value \"myName\".\r\n\r\n#####$in Find\r\nThis find allows you to specify that you are intersted in values that exist in a set. For example you may\r\nhave a collection of people, all of which have a firstName. You could then find all of the people in a set by doing the following\r\nwhich will return all records where the firstName is \"Alex\" or \"Joe\" or \"Erin\".\r\n```javascript\r\nmyCollection.find({\"$in\": [\"Alex\", \"Joe\", \"Erin\"]});\r\n```\r\n\r\n#####$spec Find\r\nThis find allows you to specify a policy that must be satisfied for the item to be included in the results.\r\nLet's say, for example, that you have a collection of cars. These cars all have doors and a price. If you want to find\r\nall cars that have 4 doors and are less than $30,000.00 you could do the following:\r\n```javascript\r\nmyCollection.find({\"$spec\": function(item) {\r\n  return item.doors == 4 && item.price < 300000;\r\n}});\r\n```\r\nYou can also pass a $.spec if you are using ku4js-kernel.\r\n```javascript\r\nmyCollection.find({\"$spec\": $.spec(function(item) {\r\n  return item.doors == 4 && item.price < 300000;\r\n})}.\r\n```\r\nFor those unfamiliar with spec, this may look like an unnecessary step and you can simply stick to functions.\r\nFor those who have harnessed the power of specs know that you can safely pass them in a $spec find.\r\n\r\n#####$orderby Find\r\nThis allows you to order your results in ascending or descending order. To ascend you pass 1 to descend you pass -1. You\r\nwill pass the 1 or -1 as a value of the key on which you want to order by.\r\n```javascript\r\nmyCollection.find({\"$orderby\": {\"price\": -1}});\r\n```\r\nFor more powerful ordering, you may also pass a function that takes parameters a and b where a and b are the expected\r\nvalues of the keys for each object to be evaluates. The function should return 1, 0, -1, true or false.\r\n```javascript\r\nmyCollection.find({\"$orderby\": {\"price\": function(a, b) { return a-b }}});\r\n```\r\n\r\n#####Complex Find\r\nYou can use all of the various finds together as well! But they will run in a specified order. First a simple find or\r\nan $in runs. Then the $spec will run on the results of the simple find or $in results. Finally, $orderby will run to\r\nsort the results accordingly. For example, let's say we have a collection of cars and we want to find all cars of make:\r\nBMW, Volvo, or Honda that have a price between 30000 and 60000 and we want to order them.\r\n```javascript\r\nmyCollection.find({\r\n \"$in\": {\"make\": [\"BMW\", \"Volvo\", \"Honda\"]},\r\n \"$spec\": function(item){ return item.price > 30000 && item.price < 60000; },\r\n \"$orderby\": {\"price\": -1}\r\n});\r\n```\r\n\r\n###store\r\n_Documentation Coming Soon_\r\n","google":"UA-55799459-1","note":"Don't delete this file! It's used internally to help with page regeneration."}